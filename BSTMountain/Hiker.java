package project5;

import java.util.ArrayList;

import project5.BSTMountain.RestStop;

/**
 * This class is a Hiker class designed to travel down
 * BSTMountain. The Hiker encounters RestStops, picks up
 * supplies, and uses these supplies to solve obstacles at
 * each reststop.
 * 
 * @author Michael Shu
 * @version 5/2/21
 */
public class Hiker {

  // ArrayList of supplies the Hiker currently has
  private ArrayList<String> supplies;
  // String of the path that the Hiker has taken
  private String path;
  // ArrayList of valid paths that have reached the bottom
  private ArrayList<String> paths;
  // Value for how many nodes the Hiker has passed through
  private int currentHeight;

  /**
   * Constructor to initialize variables
   */
  public Hiker() {
    supplies = new ArrayList<String>();
    paths = new ArrayList<String>();
    path = "";
    currentHeight = 0;
  }

  /**
   * Basic wrapper function that details order of travel.
   * 
   * First, checks if x actually exists otherwise we will
   * run into a NullPointerException.
   * 
   * Then, travel down the mountain. Finally, if there are
   * any valid paths, print them.
   * 
   * @param x         the root of the Mountain
   * 
   * @param maxHeight the height of the mountain, already
   *                  generated by Mountain beforehand
   */
  public void Travel(RestStop x, int maxHeight) {
    if (x == null)
      return;

    travel(x, maxHeight);
    printPaths();
  }

  /**
   * This is the recursive method where all the traveling
   * happens. Need to first pass through a bunch of checks
   * before you can recurse down the tree, and also need
   * to code for recursing back up and back down the tree.
   * 
   * @param x         the parent node that we are looking
   *                  to check, then travel left/right
   *                  from
   * 
   * @param maxHeight the maximum height of this mountain
   */
  private void travel(RestStop x, int maxHeight) {

    // By default, add the label of x to the path with a
    // space
    path += x.getLabel() + " ";

    if (x.getRight() == null && x.getLeft() == null) {
      if (maxHeight == currentHeight) {

        // Cut off the space we just added
        path = path.substring(0, path.length() - 1);
        // Add path to the list of good paths
        paths.add(path);

        // Ascend from bottom
        ascendFromBottom(x);

      } else {
        // If we haven't reached max height, then it's a
        // cliff and we have to go back up
        ascend(x);
      }
      // Either way, we've reached the end if both
      // left/right are null. Recurse back up
      return;
    }

    // Add all supplies of the reststop to hiker supplies
    supplies.addAll(x.getSups());

    /*
     * Generate shorter reference so I don't have to type
     * out the whole thing. For instance,
     * x.getObs().size() is now temp.size()
     */
    ArrayList<String> temp = x.getObs();

    /*
     * This is a for loop that goes through obstacles and
     * sees if we have the proper supplies. If not, we
     * ascend and end this method call by returning.
     * Otherwise, remove that supply and then increase our
     * iterator
     */
    for (int i = 0; i < temp.size(); i++) {
      if (temp.get(i).equals("fallen tree")) {
        if (!(supplies.contains("axe"))) {
          ascendFromObstacle(x);
          return;
        } else {
          i++;
          supplies.remove("axe");
        }
      } else if (temp.get(i).equals("river")) {
        if (!(supplies.contains("raft"))) {
          ascendFromObstacle(x);
          return;
        } else {
          i++;
          supplies.remove("raft");
        }
      }
    }

    // If we have no food, we can't keep going down
    if (!(supplies.contains("food"))) {
      ascend(x);
      return;
    }

    /*
     * If all previous checks are fine, then we can
     * finally recurse down.
     */
    if (x.getLeft() != null) {
      descend();
      travel(x.getLeft(), maxHeight);
    }

    if (x.getRight() != null) {
      descend();
      travel(x.getRight(), maxHeight);
    }

    /*
     * If we've traveled both to the left and right, then
     * we are done at this node and the only thing left to
     * do is to recurse back upwards
     */
    ascend(x);
  }

  /**
   * This method is specifically called when you have
   * reached the bottom. It's much simpler than ascend()
   * since you only need to decreased height, add a food
   * to replicate that asecnsion, and chop off the last
   * label(no space).
   * 
   * @param x the bottom-most node that this method is
   *          called on
   */
  private void ascendFromBottom(RestStop x) {
    path = path.substring(0,
        path.length() - x.getLabel().length());
    currentHeight -= 1;
    supplies.add("food");
  }

  /**
   * This method is specifically called when you reach an
   * obstacle. Doesn't re-add axe/raft based off of the
   * reststops obstacles.
   * 
   * @param x the node with the obstacle
   */
  private void ascendFromObstacle(RestStop x) {
    path = path.substring(0,
        path.length() - x.getLabel().length() - 1);
    currentHeight -= 1;
    supplies.add("food");
  }

  /**
   * Asenscion is the most difficult part of BSTMountain.
   * This is because of supplies. We have to know what the
   * original state of a certain node was in terms of
   * food, rafts, and axes.
   * 
   * Lets take food for example. Each time you ascend, add
   * a food on. If the RestStop you've ascended from has x
   * amount of food as supplies, then remove x amount of
   * food.
   * 
   * Rafts and axes are a similar concept. However, you
   * can only add axes/rafts at certain times; when you
   * pass a river/fallen tree, because to get to the lower
   * level you must have used an axe/raft.
   * 
   * However, I have programmed so that you can arrive at
   * a restStop with an axe AND a fallen tree, and use
   * that axe to clear the fallen tree with no problems.
   * 
   * So then, you also have to re-check for removal to see
   * if you got the axe from THIS node.
   * 
   * @param x The node ascend is called on
   */
  private void ascend(RestStop x) {

    path = path.substring(0,
        path.length() - x.getLabel().length() - 1);
    supplies.add("food");
    currentHeight -= 1;

    ArrayList<String> temp = x.getSups();
    ArrayList<String> obs = x.getObs();

    for (int i = 0; i < obs.size(); i++) {
      if (obs.get(i).equals("fallen tree"))
        supplies.add("axe");

      if (obs.get(i).equals("river")) {
        supplies.add("raft");
      }
    }

    for (int i = 0; i < temp.size(); i++) {
      if (temp.get(i).equals("food"))
        supplies.remove("food");

      if (temp.get(i).equals("axe")) {
        if (supplies.contains("axe"))
          supplies.remove("axe");
      }

      if (temp.get(i).equals("raft")) {
        if (supplies.contains("raft"))
          supplies.remove("raft");
      }
    }
  }

  /**
   * This is a simple function that entails what happens
   * every time the Hiker moves down one node
   */
  private void descend() {
    supplies.remove("food");
    currentHeight += 1;
  }

  /**
   * This method is called once at the end, to print each
   * entry in paths
   */
  private void printPaths() {
    for (int i = 0; i < paths.size(); i++) {
      System.out.println(paths.get(i));
    }
  }

}
